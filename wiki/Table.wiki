#summary Table implementation for many purposes
#labels Table,ArrayTable

= Table =

The utils-apl-derived project has one highlight which is its Table implementation.

Since Java and other frameworks provides maps and lists but lack of a direct Table, this implementation aims to fill this space of need.

The further purpose is the integration of different sources into one common easy to access structure. It is not an aim to provide high performance with the Table implementations, they should just allow to load things very easy and fast. E.g. configuration files or small sized table contents.

The central [http://www.google.com/codesearch#agM0M4Gok3c/trunk/utils-apl-derived/src/main/java/org/omnaest/utils/structure/table/Table.java&q=Table%20package:http://utils-apl-derived%5C.googlecode%5C.com Table interface] has one major implementation call [http://www.google.com/codesearch#agM0M4Gok3c/trunk/utils-apl-derived/src/main/java/org/omnaest/utils/structure/table/ArrayTable.java ArrayTable]

The Table can be marshalled to and unmarshalled from
 * CSV
 * Plain text
 * XML (JAXB)
 * XLS (Microsoft Excel)
 
 (See the [http://code.google.com/p/utils-apl-derived/source/browse/trunk/utils-apl-derived/src/test/java/org/omnaest/utils/structure/table/concrete/internal/serializer/TableSerializerImplTest.java Serializer test] for examples)

An example for plain text will look like:
{{{
=====Table1=====
!  !c0 !c1 !c2 !
!r0!0:0|0:1|0:2|
!r1!1:0|1:1|1:2|
!r2!2:0|2:1|2:2|
!r3!3:0|3:1|3:2|
----------------
}}}

or a joined Table:

{{{
=============[t1, t2]=============
!            !t1c0!t1c1!t2c0!t2c1!
![t1r0, t2r0]!0:0 |0:1 |0:0 |0:1 |
![t1r1, t2r0]!1:0 |1:1 |0:0 |0:1 |
![t1r0, t2r1]!0:0 |0:1 |1:0 |1:1 |
![t1r1, t2r1]!1:0 |1:1 |1:0 |1:1 |
----------------------------------
}}}

== TableAdapter and TableDataSource == 

The Table class can be used in combination with adapters. E.g.:

 * TableListToCallableStatementAdapter
 * TableToResultSetAdapter
 
 All available adapters should be derivates from the TableAdapter interface.

=== Mocking SQL CallableStatement and ResultSet for JDBC connection===

With help of the SQL adapters for a 
 * CallableStatement
 * ResultSet
it is possible to mock JDBC connection calls with the content of the Table. Since the Table has many input sources like XML or CSV even small to middlesized tables can be mocked easily.

Example for returning a ResultSet:
{{{
table.as().resultSet()
}}}

Example for returning a CallableStatement:
{{{
Table<String>     table1            = new ArrayTable<String>();
Table<String>     table2            = new ArrayTable<String>();
  
CallableStatement callableStatement = new TableListToCallableStatementAdapter( table1, table2 );
}}}

=== Protocolling the content of a ResultSet ===

With help of the Table it is possible to read in the content of an SQL ResultSet.
This can be achieved by using the {{{TableDataSourceResultSet}}} and the {{{Table.copyOf(...)}}} method.

See [http://www.google.com/codesearch#agM0M4Gok3c/trunk/utils-apl-derived/src/test/java/org/omnaest/utils/structure/table/datasource/TableDataSourceResultSetTest.java&q=TableDataSourceResultSetTest%20package:http://utils-apl-derived%5C.googlecode%5C.com&l=32 TableDataSourceResultSetTest] for an example using an H2 in memory database.

== Selection ==

The Table supports select statements in fluent language which are quite similar to the real SQL statements.

E.g:

{{{
Table<String> tableResult = this.table1.select()
                                       .allColumns()
                                       .innerJoin( this.table2 )
                                       .on( equalColumns( this.table1.getColumn( 0 ), this.table2.getColumn( 0 ) ) )
                                       .where( columnValueIsIn( Arrays.asList( "2:1", "4:1" ), this.table1.getColumn( 1 ),
                                                                this.table2.getColumn( 1 ) ) )
                                       .asTable();
}}}

For more examples take a look into the JUnit tests for the PredicateFilter derived classes.

E.g.:
[http://utils-apl-derived.googlecode.com/svn/trunk/utils-apl-derived/src/test/java/org/omnaest/utils/structure/table/concrete/predicates/internal/filter/ColumnValueIsInTest.java ColumnValueIsInTest]

[http://code.google.com/p/utils-apl-derived/source/browse/trunk/utils-apl-derived/src/test/java/org/omnaest/utils/structure/table/concrete/predicates/internal/filter/ Filter test package]

== Serializer ==

A Table can be easily marshalled an unmarshalled by calling the {{{serializer()}}} method.

E.g.:

{{{
Table<Object> table = new ArrayTable<Object>()
File file = new File( "test.xls" );

/* Writes the Table content to the file */
table.serializer().marshal( new TableMarshallerXLS<Object>( "worksheet1" ) ).writeTo( file );

/* Loads the file content into the Table */
table.serializer().unmarshal( new TableUnmarshallerXLS<Object>() ).from( file );
}}}

== Conversion to JavaBeans ==

It is possible to access the Table as a list of JavaBeans:

{{{
table.as().listOfType( RowBean.class );
}}}

= Javadoc =

[http://utils-apl-derived.googlecode.com/svn/wiki/apidocs/org/omnaest/utils/structure/table/Table.html Table]

= Performance and resource needs = 

 * Writing 5000 lines to an XLS file: 3000ms (~64MB heap space)
 * Simply creating 8000 lines: 3500ms (~64MB heap space)